<!DOCTYPE html>
<html>
  <head>
    <title>Android training - Services</title>
    <meta charset='utf-8'>
    <script src='../res/slides.js'></script>
  </head>
  <body style='display: none'>
    <section class='slides layout-regular template-default'>
    
<article>
<!-- ==================================================== -->

<h1>Services</h1>  

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>What is a service?</h3>
<p>A Service is an application component that can perform 
long-running operations in the background and does not provide a 
user interface</p>
<br />
<p><span class="blue">Is a facility for the application to tell 
  the system about something it wants to be doing in the background</span></p>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>Why services?</h3>
<ul>
  <li>The lifecycle is not affected by configuration changes</li>
  <li>Run completely independently of activities</li>
  <li>A Service is not a separate process unless specified</li>
  <li>Can be used as api for third-party integration</li>
</ul> 

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->   
   
<h3>And... Remote Services</h3>
<p><span class="blue">A facility for an application to expose 
  some of its functionality to other applications. This corresponds to calls to 
  Context.bindService(), which allows a long-standing connection 
  to be made to the service in order to interact with it.</span></p>
<br/>
<p>MusicPlayer service</p> 

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>How to use service</h3>
<p>You can use a start service asking to do something</p>
<br />
<p>You can bind to a service and interact with it</p>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>Service</h3>
<p>A service start when another application component like an
Activity calls <span class="blue">startIntent()</span></p>
<br />
<p>A service should stop itself! User get you bad 
reviews if services are left running.</p>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>Binding Service</h3>
<p>A service is "bound" when an application component binds 
to it by calling <span class="blue">bindService()</span></p>
<br />
<p>A bound service offers a client-server interface that allows 
components to interact with the service, send requests, get results</p>
<br />
<p>A bound service runs only as long as another 
application component is bound to it.</p>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>Service implementation</h3>
<p>Just extend Service!</p>
<pre><code>public class ExampleService extends Service {
  @Override
  public void onCreate() {}
  @Override
  public void onDestroy() {}  
  @Override
  public int onStartCommand(Intent intent, int flags, 
    int startId) {}
  @Override
  public IBinder onBind(Intent intent) {
    // used for remote services
    return null;
  }
}
</code></pre>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>Declaration</h3>
<p>You need to declare a service in the manifest</p>
<pre><code>&lt;service
  android:exported="true"
  android:name=".SearchService" &gt;
&lt;/service&gt;
</code></pre>
<pre><code>&lt;service
  android:exported="true"
  android:name=".SearchService" &gt;
  &lt;intent-filter &gt;
    &lt;action android:name="com.novoda.appinaday.Search" /&gt;
  &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre>


<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>Declaration</h3>
<p>Services can be used by other applications</p>
<br />
<p>You can ensure that your service is private to your application 
only if you include the <span class="blue">android:exported</span> 
attribute and set it to "false". 
This is effective even if your service supplies intent filters</p>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>How to start services?</h3>
<p>Use the startService method from the context</p>
<pre><code>startService(new Intent(this, MyService.class))</code></pre>
<p>In alternative you can use the direct class if you have defined a filter</p>
<pre><code>Intent i = new Intent("com.novoda.appinaday.Search");
i.putExtra("keyword", keyword);
startService(i);
</code></pre>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>Start a service</h3>
<br />
<p>If it is not already running</p>
<ul>
  <li>onCreate</li>
  <li>onStart</li>
</ul>
<br />
<p>If it is already running call</p>
<ul>
  <li>onStart</li>
</ul>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>onStart (pre-2.0) vs onStartCommand</h3>
<pre><code>@Override
public void onStart(Intent intent, int startId) {
  handleCommand(intent);
}

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
  handleCommand(intent);
  return START_STICKY;
}

protected void handleCommand(Intent intent) {
  //real work
}
</code></pre>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>onStartCommand returned value</h3>
<br />
<p><span class="blue">START_NOT_STICKY</span>kills the service after onStartCommand() returns, do not recreate the service, unless there are pending intents to deliver. This is the safest option to avoid running your service when not necessary.</p>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>onStartCommand returned value</h3>
<br />
<p><span class="blue">START_STICKY</span> If the system kills the service after onStartCommand() returns, recreate the service and call onStartCommand(), but do not redeliver the last intent. Instead, the system calls onStartCommand() with a null intent, unless there were pending intents to start the service, in which case, those intents are delivered. This is suitable for media players (or similar services) that are not executing commands, but running indefinitely and waiting for a job.</p>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>onStartCommand returned value</h3>
<br />
<p><span class="blue">START_REDELIVER_INTENT</span> : If the system kills the service after onStartCommand() returns, recreate the service and call onStartCommand() with the last intent that was delivered to the service. Any pending intents are delivered in turn. This is suitable for services that are actively performing a job that should be immediately resumed, such as downloading a file.</p>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>Stopping a service</h3>
<br />
<p>Call stopService() with an Intent that identifies the service</p>
<br />
<p>Service calls stopSelf() used with intent service</p>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>Local Binding</h3>
<p>Create a LocalBinder in the service</p>
<pre><code>private final IBinder mBinder = new LocalBinder();

public class LocalBinder extends Binder {
  public LoggingService getService() {
      return LoggingService.this;
  }
}</code></pre>
<p>Make sure to return it in the onBind</p>
<pre><code>@Override
public IBinder onBind(Intent arg0) {
  return mBinder;
}
</code></pre>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>Local Binding</h3>
<p>In the activity first you need to implement a service connection</p>
<pre><code>private ServiceConnection serviceConnection 
    = new ServiceConnection() {
  @Override
  public void onServiceConnected(ComponentName className, 
      IBinder service) {
    //here you get the binder and you can call any method on service
  }
  @Override
  public void onServiceDisconnected(ComponentName className) {
    serviceConnection = null;
  }
};
</code></pre>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>Local Binding</h3>
<p>In the activity bind the service with the connection</p>
<pre><code>bindService(new Intent(this, LoggingService.class), 
  serviceConnection, Context.BIND_AUTO_CREATE);</code></pre>
<p>Make sure to call unbindService when you have finished</p>
<pre><code>unbindService(serviceConnection);
</code></pre>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>IntentService</h3>
<p>IntentService are a particular version of services (subclass)
  that runs on a background thread and it is design 
  to implement the command pattern</p>
<pre><code>public class ExampleIntentService extends IntentService {
  @Override
  protected void onHandleIntent(Intent intent) {
    //do the work
  }
}
</code></pre>
<p>Most importantly they stop after onHandleIntent is finished</p>

<!-- ==================================================== -->
</article><!-- slide separator--><article>
<!-- ==================================================== -->

<h3>IntentService</h3>
<br />
<p>Service that uses a worker thread to handle all start requests, one at a time</p>
<br />
<p>Best option if you don't require that your service handle multiple requests simultaneously</p>
<!-- ==================================================== -->
</article>

    </section>
  </body>
</html>